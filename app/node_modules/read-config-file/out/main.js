"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orNullIfFileNotExist = orNullIfFileNotExist;
exports.orIfFileNotExist = orIfFileNotExist;
exports.getConfig = getConfig;
exports.loadEnv = exports.validateConfig = exports.loadParentConfig = exports.loadConfig = exports.findAndReadConfig = exports.readConfig = void 0;

function _bluebirdLst() {
  const data = require("bluebird-lst");

  _bluebirdLst = function () {
    return data;
  };

  return data;
}

function _fsExtraP() {
  const data = require("fs-extra-p");

  _fsExtraP = function () {
    return data;
  };

  return data;
}

function _jsYaml() {
  const data = require("js-yaml");

  _jsYaml = function () {
    return data;
  };

  return data;
}

var path = _interopRequireWildcard(require("path"));

function _ajv() {
  const data = _interopRequireDefault(require("ajv"));

  _ajv = function () {
    return data;
  };

  return data;
}

function _ajvErrorNormalizer() {
  const data = require("./ajvErrorNormalizer");

  _ajvErrorNormalizer = function () {
    return data;
  };

  return data;
}

function _dotenv() {
  const data = require("dotenv");

  _dotenv = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

let readConfig = (() => {
  var _ref = (0, _bluebirdLst().coroutine)(function* (configFile) {
    const data = yield (0, _fsExtraP().readFile)(configFile, "utf8");
    let result;

    if (configFile.endsWith(".json5") || configFile.endsWith(".json")) {
      result = require("json5").parse(data);
    } else if (configFile.endsWith(".js")) {
      result = require(configFile);
    } else if (configFile.endsWith(".toml")) {
      result = require("toml").parse(data);
    } else {
      result = (0, _jsYaml().safeLoad)(data);
    }

    return {
      result,
      configFile
    };
  });

  return function readConfig(_x) {
    return _ref.apply(this, arguments);
  };
})();

exports.readConfig = readConfig;

let findAndReadConfig = (() => {
  var _ref2 = (0, _bluebirdLst().coroutine)(function* (request) {
    const prefix = request.configFilename;

    for (const configFile of [`${prefix}.yml`, `${prefix}.yaml`, `${prefix}.json`, `${prefix}.json5`, `${prefix}.toml`]) {
      const data = yield orNullIfFileNotExist(readConfig(path.join(request.projectDir, configFile)));

      if (data != null) {
        return data;
      }
    }

    return null;
  });

  return function findAndReadConfig(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

exports.findAndReadConfig = findAndReadConfig;

function orNullIfFileNotExist(promise) {
  return orIfFileNotExist(promise, null);
}

function orIfFileNotExist(promise, fallbackValue) {
  return promise.catch(e => {
    if (e.code === "ENOENT" || e.code === "ENOTDIR") {
      return fallbackValue;
    }

    throw e;
  });
}

let loadConfig = (() => {
  var _ref3 = (0, _bluebirdLst().coroutine)(function* (request) {
    let packageMetadata = request.packageMetadata == null ? null : yield request.packageMetadata.value;

    if (packageMetadata == null) {
      packageMetadata = yield orNullIfFileNotExist((0, _fsExtraP().readJson)(path.join(request.projectDir, "package.json")));
    }

    const data = packageMetadata == null ? null : packageMetadata[request.packageKey];
    return data == null ? findAndReadConfig(request) : {
      result: data,
      configFile: null
    };
  });

  return function loadConfig(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

exports.loadConfig = loadConfig;

function getConfig(request, configPath) {
  if (configPath == null) {
    return loadConfig(request);
  } else {
    return readConfig(path.resolve(request.projectDir, configPath));
  }
}

let loadParentConfig = (() => {
  var _ref4 = (0, _bluebirdLst().coroutine)(function* (request, spec) {
    let isFileSpec;

    if (spec.startsWith("file:")) {
      spec = spec.substring("file:".length);
      isFileSpec = true;
    }

    let parentConfig = yield orNullIfFileNotExist(readConfig(path.resolve(request.projectDir, spec)));

    if (parentConfig == null && isFileSpec !== true) {
      let resolved = null;

      try {
        resolved = require.resolve(spec);
      } catch (e) {// ignore
      }

      if (resolved != null) {
        parentConfig = yield readConfig(resolved);
      }
    }

    if (parentConfig == null) {
      throw new Error(`Cannot find parent config file: ${spec}`);
    }

    return parentConfig;
  });

  return function loadParentConfig(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
})();

exports.loadParentConfig = loadParentConfig;

let validateConfig = (() => {
  var _ref5 = (0, _bluebirdLst().coroutine)(function* (config, scheme, errorMessage) {
    const ajv = new (_ajv().default)({
      allErrors: true,
      coerceTypes: true,
      verbose: true,
      errorDataPath: "configuration"
    });

    require("ajv-keywords")(ajv, ["typeof"]);

    const schema = yield scheme.value;
    const validator = ajv.compile(schema);

    if (!validator(config)) {
      const error = new Error(errorMessage((0, _ajvErrorNormalizer().normaliseErrorMessages)(validator.errors, schema), validator.errors));
      error.code = "ERR_CONFIG_INVALID";
      throw error;
    }
  });

  return function validateConfig(_x6, _x7, _x8) {
    return _ref5.apply(this, arguments);
  };
})();

exports.validateConfig = validateConfig;

let loadEnv = (() => {
  var _ref6 = (0, _bluebirdLst().coroutine)(function* (envFile) {
    const data = yield orNullIfFileNotExist((0, _fsExtraP().readFile)(envFile, "utf8"));

    if (data == null) {
      return null;
    }

    const parsed = (0, _dotenv().parse)(data);

    for (const key of Object.keys(parsed)) {
      if (!process.env.hasOwnProperty(key)) {
        process.env[key] = parsed[key];
      }
    }

    require("dotenv-expand")(parsed);

    return parsed;
  });

  return function loadEnv(_x9) {
    return _ref6.apply(this, arguments);
  };
})(); exports.loadEnv = loadEnv;
//# sourceMappingURL=main.js.map